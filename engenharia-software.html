<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="pt-br" xml:lang="pt-br">
<head>
<!-- 2025-05-14 qua 20:31 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Engenharia de software</title>
<meta name="author" content="Jackson de Jesus" />
<meta name="description" content="Resumo dos conceitos de engenharia de software" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/readtheorg.css"/>
<link rel="stylesheet" type="text/css" href="src/readtheorg_theme/css/search.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/search.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/readtheorg.js"></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Engenharia de software</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Capítulos</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org8bc42a5">Capítulo 1</a>
<ul>
<li><a href="#org10b69c2">Fundamentos e modelos de processos prescritivos</a></li>
</ul>
</li>
<li><a href="#org4ee0d8d">Capítulo 2</a>
<ul>
<li><a href="#org45dba94">Principais métodos ágeis</a></li>
</ul>
</li>
<li><a href="#org07b411c">Capítulo 3</a>
<ul>
<li><a href="#orgfd3e432">Projeto de arquitetura de software, requisitos e gerenciamento de configuração</a></li>
</ul>
</li>
<li><a href="#orgb60212d">Capítulo 4</a>
<ul>
<li><a href="#org226d25c">Estimativas de esforço e custo para desenvolvimento de softwares</a></li>
</ul>
</li>
<li><a href="#orga6bba67">Capítulo 5</a>
<ul>
<li><a href="#org0693ecd">Teste de software e suas técnicas</a></li>
</ul>
</li>
<li><a href="#org93d4fd4">Capítulo 6</a>
<ul>
<li><a href="#org1177a03">Fundamentos e recursos da cultura DevOps</a></li>
</ul>
</li>
<li><a href="#org55146f8">Observações&#x2026;</a>
<ul>
<li><a href="#orgf703c25">Como organizei o conteúdo desta página</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgb80a374">Voltar para o início&#x2026;</a></div>
</div>
<div id="outline-container-org8bc42a5" class="outline-3">
<h3 id="org8bc42a5">Capítulo 1</h3>
<div class="outline-text-3" id="text-org8bc42a5">
</div>
<div id="outline-container-org10b69c2" class="outline-4">
<h4 id="org10b69c2">Fundamentos e modelos de processos prescritivos</h4>
<div class="outline-text-4" id="text-org10b69c2">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Conceito</th>
<th scope="col" class="org-left">Descrição</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><b><b>Engenharia de Software</b></b></td>
<td class="org-left">Aborda a necessidade da área em razão da complexidade e diversidade de padrões para o desenvolvimento de softwares.</td>
</tr>

<tr>
<td class="org-left"><b><b>Processos de software</b></b></td>
<td class="org-left">Um conjunto de elementos e atividades próprias de um processo de desenvolvimento de software, como atividades metodológicas, ações de engenharia de software, tarefas, produtos de trabalho, garantia de qualidade e mecanismos de controle de mudanças para cada projeto.</td>
</tr>

<tr>
<td class="org-left"><b><b>Modelos de processos prescritivos</b></b></td>
<td class="org-left">Modelos tradicionais que surgiram para organizar e direcionar atividades de desenvolvimento de software, com capacidade de prescrever um conjunto de elementos e atividades. Denominados "tradicionais" e criados com objetivos específicos para presumir o desenvolvimento de software.</td>
</tr>

<tr>
<td class="org-left"><b><b>Modelos de processos ágeis</b></b></td>
<td class="org-left">Modelos que representam uma abordagem contrária aos modelos prescritivos, com iterações curtas onde o resultado é medido pelo produto pronto. Serão estudados em detalhes futuramente.</td>
</tr>

<tr>
<td class="org-left"><b><b>Modelo em cascata</b></b></td>
<td class="org-left">Um dos principais modelos prescritivos, representa as atividades fundamentais do processo: especificação, desenvolvimento, validação e evolução. Precede uma atividade de revisão ao final de cada fase para avaliar se o projeto pode passar à fase seguinte.</td>
</tr>

<tr>
<td class="org-left"><b><b>Fases do Modelo Cascata</b></b></td>
<td class="org-left">Incluem: Definição dos requisitos (serviços, restrições e metas são estabelecidos e definidos em detalhes); Projeto do sistema e do software (requisitos são repartidos entre hardware e software); Implementação e teste de unidade (projeto é realizado como um conjunto de programas ou unidades de programa que são implementadas e testadas); Integração e teste do sistema (unidades de programa são integradas e testadas como um sistema completo); Operação e manutenção (sistema é instalado, colocado em uso e aperfeiçoado à medida que novos requisitos são descobertos).</td>
</tr>

<tr>
<td class="org-left"><b><b>Desenvolvimento incremental</b></b></td>
<td class="org-left">Um dos principais modelos prescritivos, intercala as atividades de especificação, desenvolvimento e validação. O sistema é desenvolvido como uma série de versões (incrementos), cada uma acrescentando funcionalidades à versão anterior. A primeira versão pode ter funcionalidades limitadas, e versões posteriores adicionam mudanças.</td>
</tr>

<tr>
<td class="org-left"><b><b>Integração e configuração</b></b></td>
<td class="org-left">Um dos principais modelos prescritivos, baseia-se na disponibilidade de componentes ou sistemas reutilizáveis, focando na configuração desses componentes para um novo contexto e sua integração em um sistema.</td>
</tr>

<tr>
<td class="org-left"><b><b>Modelo Espiral</b></b></td>
<td class="org-left">Tem como característica principal a realização de ciclos de prototipação para a redução de riscos de projeto. É fortemente orientado a riscos, proposto por Boehm em 1986, apresentando a ideia em ciclos iterativos. Combina prevenção e tolerância a mudanças, assumindo que mudanças são resultado de riscos e incluindo atividades explícitas de gerenciamento de riscos para sua redução.</td>
</tr>

<tr>
<td class="org-left"><b><b>Modelo Sashimi</b></b></td>
<td class="org-left">Introduz a noção de que as fases do modelo cascata não são estanques, podendo um projeto estar simultaneamente em mais de uma fase.</td>
</tr>

<tr>
<td class="org-left"><b><b>Modelos V e W</b></b></td>
<td class="org-left">Focam no teste durante o desenvolvimento de software, indicando que o teste deve ser uma preocupação constante desde o início, não apenas uma etapa final.</td>
</tr>

<tr>
<td class="org-left"><b><b>Modelo orientado a cronograma</b></b></td>
<td class="org-left">Tem foco prioritário no desenvolvimento das funcionalidades mais importantes, deixando as demais para o final para garantir que as críticas sejam entregues no prazo em caso de atrasos.</td>
</tr>

<tr>
<td class="org-left"><b><b>Entrega em estágios</b></b></td>
<td class="org-left">Tem como prioridade planejar e entregar partes prontas do sistema antes do final do projeto.</td>
</tr>

<tr>
<td class="org-left"><b><b>Prototipação evolucionária</b></b></td>
<td class="org-left">Propõe o uso de protótipos para ajudar na definição dos requisitos e na exploração de soluções de projeto. Permite que todo o sistema, ou parte dele, seja construído rapidamente para entender ou esclarecer dúvidas. O protótipo evolui até se tornar um sistema que pode ser entregue.</td>
</tr>

<tr>
<td class="org-left"><b><b>Métodos para prototipação</b></b></td>
<td class="org-left">Incluem: <b><b>Throw-away</b></b> (protótipos descartáveis, usados apenas para estudar aspectos do sistema, entender requisitos e reduzir riscos); e <b><b>Cornerstone</b></b> (protótipos fundamentais, usados para compreender todos os aspectos do throw-away e que se tornam parte do sistema final, evoluindo até se tornar o sistema entregue).</td>
</tr>

<tr>
<td class="org-left"><b><b>Rational Unified Process (RUP)</b></b></td>
<td class="org-left">Um modelo híbrido de processo, contrário a metodologias que oferecem uma visão única do processo. Aborda quatro fases no processo de software. Reúne elementos de outros modelos, apoiando prototipação e entrega incremental. Cada fase pode seguir o modo iterativo, com resultados incrementais, e as quatro fases juntas podem ser aplicadas incrementalmente ou seguir a metodologia espiral.</td>
</tr>

<tr>
<td class="org-left"><b><b>Fases do RUP</b></b></td>
<td class="org-left">Incluem: <b><b>Concepção</b></b> (elaboração de plano de negócios, identificação de entidades externas e requisitos, avaliação da contribuição do sistema para o negócio); <b><b>Elaboração</b></b> (desenvolvimento dos requisitos e da arquitetura do sistema); <b><b>Construção</b></b> (implementação e testes do sistema); <b><b>Transição</b></b> (implantação do sistema em ambiente real).</td>
</tr>

<tr>
<td class="org-left"><b><b>Disciplinas do RUP</b></b></td>
<td class="org-left">O modelo apresenta um conjunto de seis atividades lógicas de projeto (Modelagem de negócios, Requisitos, Análise e design, Implementação, Teste, Implantação) e três de apoio (Ambiente, Gerenciamento de mudança e configuração, Gerência de projeto) para cada fase.</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="outline-container-org4ee0d8d" class="outline-3">
<h3 id="org4ee0d8d">Capítulo 2</h3>
<div class="outline-text-3" id="text-org4ee0d8d">
</div>
<div id="outline-container-org45dba94" class="outline-4">
<h4 id="org45dba94">Principais métodos ágeis</h4>
<div class="outline-text-4" id="text-org45dba94">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Conceito</th>
<th scope="col" class="org-left">Descrição</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><b><b>Métodos ágeis de desenvolvimento de software</b></b></td>
<td class="org-left">Surgiram em um esforço para sanar fraquezas da engenharia de software convencional, especialmente a sobrecarga dos modelos prescritivos em sistemas menores.</td>
</tr>

<tr>
<td class="org-left"><b><b>Desenvolvimento ágil</b></b></td>
<td class="org-left">Abordagem de desenvolvimento de software que busca sanar fraquezas da engenharia convencional.</td>
</tr>

<tr>
<td class="org-left"><b><b>Manifesto Ágil</b></b></td>
<td class="org-left">Documento que define a filosofia ágil, valorizando indivíduos e interações, software em funcionamento, colaboração com o cliente e resposta a mudanças, mais que processos e ferramentas, documentação abrangente, negociação de contratos e seguir um plano.</td>
</tr>

<tr>
<td class="org-left"><b><b>Agilidade</b></b></td>
<td class="org-left">Mais que uma resposta à mudança, abrange a filosofia do manifesto ágil. Incentiva comunicação fácil em equipe, entrega rápida de software operacional, cliente como parte da equipe e planos flexíveis. Pode ser aplicada a qualquer projeto, sendo essencial que a equipe possa adaptar tarefas, planejar compreendendo a fluidez, eliminar artefatos não essenciais e enfatizar entrega incremental.</td>
</tr>

<tr>
<td class="org-left"><b><b>Princípios do Manifesto Ágil</b></b></td>
<td class="org-left">Doze princípios que definem o espírito ágil, incluindo priorizar satisfação do cliente, aceitar mudanças, entregar software frequentemente, colaborar com cliente, confiar em indivíduos motivados, comunicação face a face, software em funcionamento como medida de progresso, desenvolvimento sustentável, excelência técnica, simplicidade, equipes auto-organizadas e autoavaliação regular.</td>
</tr>

<tr>
<td class="org-left"><b><b>Método XP (Extreme Programming)</b></b></td>
<td class="org-left">Um método ágil que requer seguir uma série de práticas relacionadas ao cliente, gerência, programação e testes.</td>
</tr>

<tr>
<td class="org-left"><b><b>Práticas do Método XP</b></b></td>
<td class="org-left">Incluem: Jogo de planejamento (equipe e cliente priorizam funcionalidades semanalmente); Programação em pares (dois programadores na mesma máquina, um usando a máquina e outro auxiliando); Padrões de codificação (equipe segue padrões para o código parecer ter sido desenvolvido pela mesma pessoa); Testes de aceitação (planejados e conduzidos com o cliente para verificar requisitos); Desenvolvimento orientado a teste (definir e implementar testes antes de programar a unidade); Refatoração (não fugir da refatoração para manter complexidade gerenciável); Integração contínua (integrar funcionalidade assim que viável para evitar surpresas).</td>
</tr>

<tr>
<td class="org-left"><b><b>Método FDD (Feature Driven-Development)</b></b></td>
<td class="org-left">Método ágil que enfatiza orientação a objetos, apresentado em 1997. Dividido em duas fases.</td>
</tr>

<tr>
<td class="org-left"><b><b>Fases do Método FDD</b></b></td>
<td class="org-left">Incluem: <b><b>Concepção e planejamento</b></b> (pensar antes de construir, em geral de uma a duas semanas); <b><b>Construção</b></b> (desenvolvimento iterativo do produto em ciclos de uma a duas semanas).</td>
</tr>

<tr>
<td class="org-left"><b><b>Disciplinas do Método FDD</b></b></td>
<td class="org-left">Na fase de Concepção e planejamento: Desenvolver Modelo Abrangente (uso de modelagem orientada a objetos); Construir Lista de Funcionalidades (decomposição funcional para identificar funcionalidades); Planejar por Funcionalidade (planejamento de ciclos iterativos baseado em funcionalidades). Na fase de Construção: Detalhar por Funcionalidade (design orientado a objetos); Construir por Funcionalidade (construir e testar software usando linguagem e técnica orientadas a objetos).</td>
</tr>

<tr>
<td class="org-left"><b><b>Método DSDM (Dynamic Systems Development Method)</b></b></td>
<td class="org-left">Modelo ágil baseado em desenvolvimento iterativo e incremental com participação ativa do usuário. Composto por três fases.</td>
</tr>

<tr>
<td class="org-left"><b><b>Fases do Método DSDM</b></b></td>
<td class="org-left">Incluem: <b><b>Pré-projeto</b></b> (projeto é identificado, negociado, orçamento definido, contrato assinado); <b><b>Ciclo de vida</b></b> (inicia com análise de viabilidade e negócio, depois entra em ciclos iterativos de desenvolvimento); <b><b>Pós-projeto</b></b> (período considerado de manutenção). A fase de Ciclo de Vida se concentra nas atividades de Exploração, Engenharia e Desenvolvimento em ciclos iterativos.</td>
</tr>

<tr>
<td class="org-left"><b><b>Princípios da filosofia DSDM</b></b></td>
<td class="org-left">Incluem: Envolvimento do usuário o tempo todo; Autonomia dos desenvolvedores para tomar decisões; Entregas frequentes de releases suficientemente boas; Eficácia das entregas na solução de problemas de negócio; Feedback dos usuários realimentando o processo; Reversibilidade de todas as ações; Previsibilidade do escopo e objetivos das iterações; Ausência de testes no escopo (considera teste fora do ciclo de vida).</td>
</tr>

<tr>
<td class="org-left"><b><b>Método Crystal Clear</b></b></td>
<td class="org-left">Método ágil criado por Alistair Cockburn em 1997, adequado para equipes pequenas (até 8 pessoas) que trabalham juntas. Propõe o uso de radiadores de informação, acesso fácil a especialistas, eliminação de distrações, cronograma e ajuste do método.</td>
</tr>

<tr>
<td class="org-left"><b><b>Ciclo de vida do Crystal Clear</b></b></td>
<td class="org-left">Organizado em três níveis: Iteração (estimação, desenvolvimento, celebração, dura poucas semanas); Entrega (várias iterações, entrega funcionalidades úteis em no máximo dois meses); Projeto (conjunto de todas as entregas).</td>
</tr>

<tr>
<td class="org-left"><b><b>Pilares do Crystal Clear</b></b></td>
<td class="org-left">Incluem: Entrega frequente de software utilizável; Melhoria reflexiva (equipe reflete regularmente sobre seu processo); Comunicação osmótica (equipe na mesma sala ou contíguas para ouvir conversas relevantes); Segurança pessoal (desenvolvedores podem falar sem medo); Foco (membros da equipe têm tópicos de alta prioridade para trabalhar tranquilamente); Cooperação; Ambiente técnico com integração frequente e testes automatizados.</td>
</tr>

<tr>
<td class="org-left"><b><b>Método ASD (Adaptive Software Development)</b></b></td>
<td class="org-left">Modelo ágil baseado em desenvolvimento cíclico iterativo. Fundamenta-se em três grandes fases.</td>
</tr>

<tr>
<td class="org-left"><b><b>Fases do Modelo ASD</b></b></td>
<td class="org-left">Incluem: <b><b>Especular</b></b> (início do projeto, planejamento de ciclos adaptáveis, definindo duração, ciclos, objetivos, componentes, tecnologias e tarefas); <b><b>Colaborar</b></b> (foco no desenvolvimento dos componentes especificados); <b><b>Aprender</b></b> (revisão da qualidade, testes e manutenção). As três fases formam um ciclo iterativo.</td>
</tr>

<tr>
<td class="org-left"><b><b>Método Scrum</b></b></td>
<td class="org-left">Modelo ágil para a gestão de projetos de software. Um dos conceitos mais importantes é o Sprint. Segue três fases na execução.</td>
</tr>

<tr>
<td class="org-left"><b><b>Fases do Método Scrum</b></b></td>
<td class="org-left">Incluem: <b><b>Planejamento geral</b></b> (estabelece objetivos gerais do projeto e arquitetura); <b><b>Série de ciclos de Sprint</b></b> (cada ciclo desenvolve um incremento do sistema); <b><b>Encerramento do projeto</b></b> (completa documentação e avalia lições aprendidas).</td>
</tr>

<tr>
<td class="org-left"><b><b>Papéis do Método Scrum</b></b></td>
<td class="org-left">Incluem: <b><b>Scrum Master</b></b> (responsável por manter o time em ambiente propício, facilitador e solucionador de conflitos); <b><b>Product Owner</b></b> (representa a voz do cliente, responsável pelo valor de negócio e necessidades dos clientes, indica requisitos mais importantes por sprint); <b><b>Scrum team</b></b> (responsável pelo desenvolvimento das entregas, entende requisitos, equipe de desenvolvimento geralmente com 6 a 10 pessoas).</td>
</tr>

<tr>
<td class="org-left"><b><b>Product Backlog (Scrum)</b></b></td>
<td class="org-left">Lista das funcionalidades a serem implementadas em cada projeto, como os requisitos. Não precisa ser completo no início do projeto, podendo começar com as funcionalidades mais evidentes.</td>
</tr>

<tr>
<td class="org-left"><b><b>Sprint (Scrum)</b></b></td>
<td class="org-left">Ciclo de desenvolvimento com poucas semanas de duração. No início de cada Sprint, a equipe prioriza elementos do Product Backlog para o Sprint Backlog.</td>
</tr>

<tr>
<td class="org-left"><b><b>Sprint Backlog (Scrum)</b></b></td>
<td class="org-left">Lista de funcionalidades a serem implementadas no ciclo (Sprint) que se inicia. O Product Owner deve mantê-lo atualizado durante o Sprint.</td>
</tr>

<tr>
<td class="org-left"><b><b>Reuniões no Scrum</b></b></td>
<td class="org-left">Incluem: <b><b>Reuniões diárias</b></b> (equipe se reúne diariamente para compartilhar o que fez ontem, o que fará hoje e quais impedimentos enfrenta); <b><b>Reunião de Revisão</b></b> (ao final de cada Sprint, para avaliar o que foi feito e receber feedback do Product Owner e stakeholders); <b><b>Reunião de Retrospectiva</b></b> (ao final de cada Sprint, para a equipe autoavaliar seu desempenho e identificar melhorias).</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="outline-container-org07b411c" class="outline-3">
<h3 id="org07b411c">Capítulo 3</h3>
<div class="outline-text-3" id="text-org07b411c">
</div>
<div id="outline-container-orgfd3e432" class="outline-4">
<h4 id="orgfd3e432">Projeto de arquitetura de software, requisitos e gerenciamento de configuração</h4>
<div class="outline-text-4" id="text-orgfd3e432">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Conceito</th>
<th scope="col" class="org-left">Descrição</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><b><b>Projeto de arquitetura de software</b></b></td>
<td class="org-left">Tarefa de definir a estrutura geral do sistema, partindo do contexto geral para então distribuir os processos e componentes. Representa a estrutura de dados e componentes necessários, considerando o estilo de arquitetura, estrutura e propriedades dos componentes e suas inter-relações.</td>
</tr>

<tr>
<td class="org-left"><b><b>Projeto</b></b></td>
<td class="org-left">Definido como "um esforço temporário empreendido para criar um produto, serviço ou resultado único" (Guia PMBOK) e "um empreendimento planejado, orientado a resultados, possuindo atividades com início e término, para atingir um objetivo claro e definido" (Metodologia SISP).</td>
</tr>

<tr>
<td class="org-left"><b><b>Projeto de software</b></b></td>
<td class="org-left">Um processo em várias etapas onde representações de dados, estrutura do programa, características de interfaces e detalhes procedurais são sintetizados com base nos requisitos. Corresponde a um esquema preliminar pelo qual o software é construído, considerando domínios de dados, funcional e comportamental.</td>
</tr>

<tr>
<td class="org-left"><b><b>Estilo ou padrão de arquitetura</b></b></td>
<td class="org-left">Descrição abstrata, estilizada, de práticas recomendadas testadas e aprovadas em diferentes subsistemas e ambientes. O projeto de arquitetura considera o estilo que o sistema assumirá.</td>
</tr>

<tr>
<td class="org-left"><b><b>Etapas do projeto de arquitetura</b></b></td>
<td class="org-left">Incluem: Definir entidades externas com as quais o software interage; Identificar arquétipos arquiteturais (abstrações de elementos do sistema, similares a classes); Análise de estilos ou padrões de arquitetura alternativos; Implementação da arquitetura utilizando um modelo de processos.</td>
</tr>

<tr>
<td class="org-left"><b><b>Projeto conceitual</b></b></td>
<td class="org-left">Primeira fase do processo iterativo de projeto, apresenta ao cliente o que o sistema fará.</td>
</tr>

<tr>
<td class="org-left"><b><b>Projeto técnico (ou lógico)</b></b></td>
<td class="org-left">Deriva do projeto conceitual após aprovação do cliente, sendo um modelo mais detalhado focado nas definições técnicas para o desenvolvimento.</td>
</tr>

<tr>
<td class="org-left"><b><b>Padrões de arquitetura de software</b></b></td>
<td class="org-left">Diversos padrões que podem ser utilizados no desenvolvimento de sistemas, como arquitetura centralizada em dados, fluxo de dados, orientada a objetos, MVC, entre outros.</td>
</tr>

<tr>
<td class="org-left"><b><b>Arquitetura centralizada em dados</b></b></td>
<td class="org-left">Padrão comum em sistemas de informação, onde um repositório de dados (banco de dados) reside no centro e é acessado por outros componentes para modificar dados.</td>
</tr>

<tr>
<td class="org-left"><b><b>Arquitetura de fluxo de dados (Duto e filtro)</b></b></td>
<td class="org-left">Padrão aplicado quando dados de entrada devem ser transformados por uma série de componentes de processamento (filtros), onde cada componente realiza uma transformação de dados discreta.</td>
</tr>

<tr>
<td class="org-left"><b><b>Arquitetura orientada a objetos</b></b></td>
<td class="org-left">Padrão que fornece uma descrição abstrata do software, aproximando as estruturas do programa de conceitos do mundo real. Baseia-se em classes (conjunto de características e comportamentos) e objetos (instâncias de uma classe).</td>
</tr>

<tr>
<td class="org-left"><b><b>Arquitetura Modelo, Visão e Controlador (MVC)</b></b></td>
<td class="org-left">Padrão que foca em separar a apresentação e interação dos dados do sistema. Estruturado em três componentes lógicos: Modelo (gerencia dados e operações); Visão (define e gerencia como dados são apresentados ao usuário); Controlador (gerencia interação do usuário e a passa para Visão e Modelo).</td>
</tr>

<tr>
<td class="org-left"><b><b>Levantamento de requisitos</b></b></td>
<td class="org-left">Primeira etapa na construção de um sistema. Processo no qual engenheiros de software trabalham com clientes e usuários para obter informações sobre o domínio da aplicação, serviços, desempenho, restrições, etc..</td>
</tr>

<tr>
<td class="org-left"><b><b>Requisitos de um sistema</b></b></td>
<td class="org-left">Descrições do que o sistema deve fazer, os serviços que oferece e as restrições a seu funcionamento. Refletem as necessidades dos clientes. Classificados como funcionais e não funcionais.</td>
</tr>

<tr>
<td class="org-left"><b><b>Descoberta de requisitos</b></b></td>
<td class="org-left">Processo de reunir informações sobre o sistema requerido e sistemas existentes, separando requisitos de usuário e sistema de fontes como documentações, usuários e sistemas similares.</td>
</tr>

<tr>
<td class="org-left"><b><b>Técnicas de levantamento de requisitos</b></b></td>
<td class="org-left">Incluem: Entrevistas (formais/informais com usuários e partes interessadas); Cenários (descrições textuais ou diagramáticas de interações); Casos de uso (abordagem estruturada de cenários, identificando atores e tipo de interação); Etnografia (observação para compreender processos operacionais).</td>
</tr>

<tr>
<td class="org-left"><b><b>Especificação de requisitos</b></b></td>
<td class="org-left">Processo de escrever os requisitos de usuário e de sistema em um documento de requisitos.</td>
</tr>

<tr>
<td class="org-left"><b><b>Métodos de especificação de requisitos</b></b></td>
<td class="org-left">Incluem: Sentenças em linguagem natural (requisitos escritos em frases numeradas); Linguagem natural estruturada (requisitos em linguagem natural em formulário/template); Notações gráficas (modelos gráficos, como diagramas UML, suplementados por texto); Especificações matemáticas (baseadas em conceitos matemáticos, podem reduzir ambiguidade mas são menos compreendidas por clientes).</td>
</tr>

<tr>
<td class="org-left"><b><b>Gerenciamento de configuração e mudança</b></b></td>
<td class="org-left">Conjunto de atividades para gerenciar alterações em sistemas de software, identificando artefatos e controlando mudanças.</td>
</tr>

<tr>
<td class="org-left"><b><b>Atividades da gestão de configuração de software</b></b></td>
<td class="org-left">Incluem: Controle de versão (gerenciar diferentes versões de artefatos); Construção de sistema (reunir componentes, dados e bibliotecas para criar executável); Gerenciamento de mudanças (controlar solicitações de mudança, avaliar custo/impacto e decidir implementação); Gerenciamento de lançamentos (preparação de versões do sistema).</td>
</tr>

<tr>
<td class="org-left"><b><b>Controle de versão (Git)</b></b></td>
<td class="org-left">Sistema de controle de versão. Permite criar, gerenciar e trocar entre ramificações (branchs).</td>
</tr>

<tr>
<td class="org-left"><b><b>Ramificação (Git)</b></b></td>
<td class="org-left">Permite criar novas linhas de desenvolvimento separadas. Podem ser associadas à ramificação principal (master).</td>
</tr>

<tr>
<td class="org-left"><b><b>GitHub</b></b></td>
<td class="org-left">Plataforma para hospedagem de projetos gerenciados com Git.</td>
</tr>

<tr>
<td class="org-left"><b><b>Manutenção de software</b></b></td>
<td class="org-left">Processo geral de mudança em um sistema após sua liberação para uso.</td>
</tr>

<tr>
<td class="org-left"><b><b>Tipos de manutenção de software</b></b></td>
<td class="org-left">Incluem: Correção de defeitos; Adaptação ambiental; Adição de funcionalidade. Na prática, as distinções podem ser tênues.</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="outline-container-orgb60212d" class="outline-3">
<h3 id="orgb60212d">Capítulo 4</h3>
<div class="outline-text-3" id="text-orgb60212d">
</div>
<div id="outline-container-org226d25c" class="outline-4">
<h4 id="org226d25c">Estimativas de esforço e custo para desenvolvimento de softwares</h4>
<div class="outline-text-4" id="text-org226d25c">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Conceito</th>
<th scope="col" class="org-left">Descrição</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><b><b>Estimativas de esforço para desenvolvimento de softwares</b></b></td>
<td class="org-left">Processo para realizar estimativas adequadas de tempo, tamanho da equipe e custo para aplicação de modelos de processos e arquiteturas.</td>
</tr>

<tr>
<td class="org-left"><b><b>Análise de Ponto de Função (APF)</b></b></td>
<td class="org-left">Técnica de medição do tamanho funcional de um software. Mede o que o software faz, não como ele foi construído, baseada nos requisitos lógicos do usuário. Uma medida de tamanho funcional, usada com outras variáveis para derivar produtividade, custo e esforço.</td>
</tr>

<tr>
<td class="org-left"><b><b>Tamanho funcional de um software</b></b></td>
<td class="org-left">O que é medido pela Análise de Ponto de Função.</td>
</tr>

<tr>
<td class="org-left"><b><b>Processo de contagem de pontos de função</b></b></td>
<td class="org-left">Dividido em seis etapas: determinar tipo de contagem; identificar escopo e fronteira; contar funções (dados e transação); determinar pontos não ajustados; determinar fator de ajuste; calcular pontos ajustados (AFP).</td>
</tr>

<tr>
<td class="org-left"><b><b>Tipos de contagem (APF)</b></b></td>
<td class="org-left">Incluem: Projeto de desenvolvimento (novo projeto); Projeto de melhoria (funções adicionadas, modificadas, eliminadas em projeto existente); Aplicação (projeto finalizado).</td>
</tr>

<tr>
<td class="org-left"><b><b>Escopo de contagem (APF)</b></b></td>
<td class="org-left">Determinar se a contagem foca em um ou mais sistemas ou partes deles. Define quais funções serão incluídas.</td>
</tr>

<tr>
<td class="org-left"><b><b>Fronteira da aplicação (APF)</b></b></td>
<td class="org-left">Estabelece um divisor entre componentes do aplicativo e de outros aplicativos. É a linha que separa uma aplicação de outra.</td>
</tr>

<tr>
<td class="org-left"><b><b>Funções tipo dados (APF)</b></b></td>
<td class="org-left">Referem-se a funcionalidades para armazenamento de dados da aplicação, caracterizadas como arquivos lógicos (ALI e AIE).</td>
</tr>

<tr>
<td class="org-left"><b><b>ALI (Arquivos Lógicos Internos) (APF)</b></b></td>
<td class="org-left">Arquivos lógicos mantidos dentro da fronteira da aplicação. Ex: arquivos de configuração, tabelas de BD mantidas pela aplicação.</td>
</tr>

<tr>
<td class="org-left"><b><b>AIE (Arquivos de Interface Externa) (APF)</b></b></td>
<td class="org-left">Arquivos lógicos mantidos fora da aplicação ou lidos de outra. Ex: dados de segurança, dados salariais em outra aplicação.</td>
</tr>

<tr>
<td class="org-left"><b><b>RLR (Registros Lógicos Referenciados) (APF)</b></b></td>
<td class="org-left">Subgrupo de DER, reconhecido pelo usuário. Ex: uma tabela do banco de dados.</td>
</tr>

<tr>
<td class="org-left"><b><b>DER (Dados Lógicos Referenciados) (APF)</b></b></td>
<td class="org-left">Campo único, reconhecido pelo usuário, não repetido. Ex: um atributo de uma tabela do banco de dados. Chaves estrangeiras não são contadas como DER.</td>
</tr>

<tr>
<td class="org-left"><b><b>Funções tipo transação (APF)</b></b></td>
<td class="org-left">Representam funcionalidades de processamento de dados do sistema, classificadas em EE, SE e CE. Denominadas processos elementares.</td>
</tr>

<tr>
<td class="org-left"><b><b>Processos elementares (APF)</b></b></td>
<td class="org-left">A menor unidade de uma função disponível ao usuário, única e independente.</td>
</tr>

<tr>
<td class="org-left"><b><b>EE (Entrada Externa) (APF)</b></b></td>
<td class="org-left">Processo elementar que manipula dados ou informações de controle originados fora da fronteira, com intenção de manter (incluir, alterar, excluir) ALI ou alterar comportamento do sistema.</td>
</tr>

<tr>
<td class="org-left"><b><b>SE (Saída Externa) (APF)</b></b></td>
<td class="org-left">Processo elementar que envia dados ou informações de controle para fora, com intenção de apresentar informação ao usuário via lógica de processamento (não apenas recuperação). Ex: Relatórios com totalização, informações gráficas.</td>
</tr>

<tr>
<td class="org-left"><b><b>CE (Consulta Externa) (APF)</b></b></td>
<td class="org-left">Processo elementar que envia dados ou informações de controle para fora, com intenção de apresentar informação via simples recuperação de dados de ALI/AIE. A lógica de processamento não deve conter fórmulas/cálculos. Ex: Informações com formato gráfico.</td>
</tr>

<tr>
<td class="org-left"><b><b>Pontos de função não ajustados (AFP não ajustados)</b></b></td>
<td class="org-left">Total obtido somando-se os pontos das funções tipo dados e funções tipo transação. Representam o tamanho funcional da aplicação.</td>
</tr>

<tr>
<td class="org-left"><b><b>Fator de ajuste (APF)</b></b></td>
<td class="org-left">Fator derivado dos itens de influência que afetam o tamanho funcional de um aplicativo. Calculado por: (pontos de influência x 0,01) + 0,65.</td>
</tr>

<tr>
<td class="org-left"><b><b>Itens de influência (APF)</b></b></td>
<td class="org-left">14 características intrínsecas a um aplicativo que afetam seu tamanho funcional, cada uma pontuada de 0 a 5. Ex: Comunicação de dados, Funções distribuídas, Performance, Interface com o usuário, Reusabilidade, Facilidade de mudanças, etc..</td>
</tr>

<tr>
<td class="org-left"><b><b>Pontos de função ajustados (AFP)</b></b></td>
<td class="org-left">Obtidos multiplicando os pontos de função não ajustados pelo fator de ajuste. Processo opcional; os pontos não ajustados podem ser considerados AFP.</td>
</tr>

<tr>
<td class="org-left"><b><b>Duração e custo de um projeto (Estimativa)</b></b></td>
<td class="org-left">Para calcular o custo, é necessário saber o esforço total e o custo por hora/mês de trabalho. O custo é obtido multiplicando o esforço total pelo custo por hora/mês. A duração do projeto em horas por ponto de função varia por linguagem/tecnologia.</td>
</tr>

<tr>
<td class="org-left"><b><b>Esforço (Estimativa)</b></b></td>
<td class="org-left">O esforço total do desenvolvimento é calculado com base no tamanho funcional (AFP) e na produtividade (pontos de função produzidos por hora/mês). Obter histórico de projetos ajuda a estimar com maior precisão.</td>
</tr>

<tr>
<td class="org-left"><b><b>Pontos de Casos de Uso (PCU)</b></b></td>
<td class="org-left">Técnica de estimativa surgida em 1993, considerada mais simples que APF. Baseia-se na análise da quantidade e complexidade de atores e casos de uso, gerando pontos não ajustados (UUCP) e depois ajustados (UCP) pela aplicação de fatores.</td>
</tr>

<tr>
<td class="org-left"><b><b>UUCP (Pontos de caso de uso não ajustados)</b></b></td>
<td class="org-left">Soma dos pontos atribuídos aos casos de uso e do peso não ajustado dos atores.</td>
</tr>

<tr>
<td class="org-left"><b><b>UCP (Pontos de caso de uso ajustados)</b></b></td>
<td class="org-left">Obtidos multiplicando-se o total de UUCP pelo TCF e EF.</td>
</tr>

<tr>
<td class="org-left"><b><b>Complexidade dos atores (PCU)</b></b></td>
<td class="org-left">Definida como simples (pessoa), média (outro sistema), ou complexa (outro sistema com interface gráfica). Cada ator é contado uma única vez.</td>
</tr>

<tr>
<td class="org-left"><b><b>Complexidade dos casos de uso (PCU)</b></b></td>
<td class="org-left">Definida de três formas: por número de transações (simples: até 3, média: 4-7, complexo: acima de 7); por quantidade de classes necessárias (simples: até 5, média: 6-10, complexo: mais de 10); por análise de risco (simples: baixo risco, média: padronizado, complexo: não padronizado, alto risco). Somente casos de uso completos são contados.</td>
</tr>

<tr>
<td class="org-left"><b><b>Fatores técnicos (PCU)</b></b></td>
<td class="org-left">Treze fatores que recebem pontuação de 0 a 5, usados na análise de PCU ajustados. Ex: Sistema distribuído, Performance, Segurança, Portabilidade.</td>
</tr>

<tr>
<td class="org-left"><b><b>TCF (Fator de complexidade técnica) (PCU)</b></b></td>
<td class="org-left">Fator calculado com base nos 13 fatores técnicos: 0,6 + (0,01 * total da soma dos pontos de fatores técnicos).</td>
</tr>

<tr>
<td class="org-left"><b><b>Fatores ambientais (PCU)</b></b></td>
<td class="org-left">Oito fatores específicos às características da equipe de desenvolvimento, usados na análise de PCU ajustados. Ex: Familiaridade com o processo, Experiência com a aplicação, Motivação, Equipe em tempo parcial.</td>
</tr>

<tr>
<td class="org-left"><b><b>EF (Fator ambiental total) (PCU)</b></b></td>
<td class="org-left">Fator calculado com base nos 8 fatores ambientais: 1,4 – (0,03 x total da soma dos fatores ambientais).</td>
</tr>

<tr>
<td class="org-left"><b><b>Pontos de Histórias (PH)</b></b></td>
<td class="org-left">Técnica de estimativa variante da APF, preferida em métodos ágeis como Scrum e XP. Medida de esforço relativa à equipe de desenvolvimento, não de complexidade funcional.</td>
</tr>

<tr>
<td class="org-left"><b><b>História de usuário (PH)</b></b></td>
<td class="org-left">Explicação informal e geral sobre um recurso de software, escrita sob a perspectiva do usuário final. A estimativa de pontos de história pode ser feita subjetivamente pela equipe ou atribuindo pontos de acordo com o tempo de desenvolvimento.</td>
</tr>

<tr>
<td class="org-left"><b><b>Ksloc (Miles de Linhas de Código Fonte)</b></b></td>
<td class="org-left">Métrica rudimentar de estimativa baseada na quantidade de linhas de código fonte. Pode ser estimada pela equipe com valores otimista, pessimista e esperado.</td>
</tr>

<tr>
<td class="org-left"><b><b>Modelo COCOMO (Constructive Cost Model)</b></b></td>
<td class="org-left">Principal modelo de estimativa de tamanho de equipe e tempo linear de desenvolvimento. Considera Ksloc e outros fatores para estimar esforço, tempo e pessoas. Possui três modos de implementação (básica, intermediária, avançada) e considera o tipo de projeto (orgânico, semidestacado, embutido).</td>
</tr>

<tr>
<td class="org-left"><b><b>Esforço (E) (COCOMO)</b></b></td>
<td class="org-left">Esforço estimado em desenvolvedor/mês. Calculado com base em Ksloc e constantes (modelo básico) ou Ksloc e fatores influenciadores de custo (modelos intermediário/avançado).</td>
</tr>

<tr>
<td class="org-left"><b><b>Tempo linear de desenvolvimento (T) (COCOMO)</b></b></td>
<td class="org-left">Tempo sugerido em meses corridos. Calculado com base no esforço e constantes.</td>
</tr>

<tr>
<td class="org-left"><b><b>Número médio de pessoas (P) (COCOMO)</b></b></td>
<td class="org-left">Número médio de pessoas recomendado para a equipe. Calculado dividindo o esforço pelo tempo linear de desenvolvimento (E/T).</td>
</tr>

<tr>
<td class="org-left"><b><b>Fatores influenciadores de custo (COCOMO Intermediário/Avançado)</b></b></td>
<td class="org-left">15 fatores que afetam o esforço, relacionados a produto, hardware, pessoal e processo. Cada fator tem pesos que variam de Muito baixo a Muito alto.</td>
</tr>

<tr>
<td class="org-left"><b><b>EAF (Esforço de Ajuste de Fatores) (COCOMO Intermediário/Avançado)</b></b></td>
<td class="org-left">Valor obtido pela multiplicação dos 15 fatores influenciadores de custo. Utilizado no cálculo do esforço.</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="outline-container-orga6bba67" class="outline-3">
<h3 id="orga6bba67">Capítulo 5</h3>
<div class="outline-text-3" id="text-orga6bba67">
</div>
<div id="outline-container-org0693ecd" class="outline-4">
<h4 id="org0693ecd">Teste de software e suas técnicas</h4>
<div class="outline-text-4" id="text-org0693ecd">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Conceito</th>
<th scope="col" class="org-left">Descrição</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><b><b>Teste de software</b></b></td>
<td class="org-left">Uma das fases mais importantes do desenvolvimento, tem como objetivo compreender seus conceitos para identificar possíveis defeitos e revelar esses defeitos através de casos de teste adequados. É o processo de executar um programa com a intenção de revelar defeitos, não provar a ausência deles.</td>
</tr>

<tr>
<td class="org-left"><b><b>Técnicas de teste de software</b></b></td>
<td class="org-left">Três técnicas propostas na literatura: funcional, estrutural e baseada em defeitos. Distinguem-se pela fonte utilizada para definir os requisitos de teste.</td>
</tr>

<tr>
<td class="org-left"><b><b>Critérios de teste</b></b></td>
<td class="org-left">Propostas dentro das técnicas de teste que visam atingir o objetivo de revelar defeitos. Cada critério procura explorar determinados tipos de defeitos, estabelecendo requisitos de teste.</td>
</tr>

<tr>
<td class="org-left"><b><b>Engano (Conceito de teste)</b></b></td>
<td class="org-left">Caracteriza-se como uma ação equivocada de um conceito específico do domínio, geralmente causado por humanos. Pode ser, por exemplo, um erro de digitação ou lógica ao escrever o código.</td>
</tr>

<tr>
<td class="org-left"><b><b>Defeito (Conceito de teste)</b></b></td>
<td class="org-left">A existência de um defeito em um programa leva à ocorrência de um erro, desde que o defeito seja executado. Por exemplo, uma condição lógica incorreta que causa um comportamento inesperado.</td>
</tr>

<tr>
<td class="org-left"><b><b>Erro (Conceito de teste)</b></b></td>
<td class="org-left">Caracteriza-se por um estado inconsistente ou inesperado devido à execução de um defeito.</td>
</tr>

<tr>
<td class="org-left"><b><b>Falha (Conceito de teste)</b></b></td>
<td class="org-left">Pode ser ocasionada por um estado inconsistente ou inesperado (erro).</td>
</tr>

<tr>
<td class="org-left"><b><b>Dados de teste</b></b></td>
<td class="org-left">É um elemento do domínio de entrada de um programa. Ex: Para um programa que computa x<sup>y</sup> com x, y &gt; 1, (2, 5) é um dado de teste.</td>
</tr>

<tr>
<td class="org-left"><b><b>Casos de teste</b></b></td>
<td class="org-left">É um par formado por um dado de teste mais o resultado esperado para a execução do programa com aquele dado de teste. Ex: Para o dado de teste (2, 5), o caso de teste é ((2, 5), 10).</td>
</tr>

<tr>
<td class="org-left"><b><b>Domínio de entrada</b></b></td>
<td class="org-left">O conjunto de todos os possíveis valores que podem ser utilizados para executar um programa. Ex: Para um programa que computa x<sup>y</sup> para x, y &gt; 1, o domínio de entrada são todos os pares (x, y) de inteiros maiores que 1.</td>
</tr>

<tr>
<td class="org-left"><b><b>Domínio de saída</b></b></td>
<td class="org-left">O conjunto de todos os possíveis resultados produzidos por um programa.</td>
</tr>

<tr>
<td class="org-left"><b><b>Oráculo de teste</b></b></td>
<td class="org-left">Necessário para saber o resultado esperado para a execução de um dado de teste. Permite comparar os resultados obtidos com os esperados para verificar a correção do programa.</td>
</tr>

<tr>
<td class="org-left"><b><b>Teste de seleção</b></b></td>
<td class="org-left">Procura identificar quais dados de teste devem ser selecionados do domínio de entrada.</td>
</tr>

<tr>
<td class="org-left"><b><b>Teste de partição</b></b></td>
<td class="org-left">Procura estabelecer subconjuntos de dados de teste e selecionar casos de teste em cada subconjunto. Dados que satisfazem o mesmo requisito de teste (ex: executar determinada estrutura) pertencem ao mesmo subconjunto.</td>
</tr>

<tr>
<td class="org-left"><b><b>Teste de Funcionalidade (Caixa preta)</b></b></td>
<td class="org-left">Método de teste que verifica e valida se as funções implementadas no software estão corretas em seus diversos níveis. Executado sobre as entradas e saídas do programa sem conhecimento do código-fonte. Inclui testes de unidade, integração, sistema e aceitação.</td>
</tr>

<tr>
<td class="org-left"><b><b>Testes de unidade</b></b></td>
<td class="org-left">Os testes mais básicos, consistem em verificar se um componente individual do software funciona corretamente.</td>
</tr>

<tr>
<td class="org-left"><b><b>Testes de integração</b></b></td>
<td class="org-left">Feitos quando unidades prontas e testadas isoladamente precisam ser integradas para gerar uma nova versão do sistema.</td>
</tr>

<tr>
<td class="org-left"><b><b>Estratégias de integração</b></b></td>
<td class="org-left">Incluem: Big-bang (constrói e testa todas as classes/unidades juntas); Top-down (integração e teste de cima para baixo na hierarquia do sistema); Bottom-up (integração e teste de baixo para cima).</td>
</tr>

<tr>
<td class="org-left"><b><b>Testes de sistema</b></b></td>
<td class="org-left">Testes feitos quando o sistema está completo e integrado. Focam em verificar se os requisitos funcionais e não funcionais foram atendidos. A execução do fluxo principal e fluxos alternativos do caso de uso é verificada.</td>
</tr>

<tr>
<td class="org-left"><b><b>Teste de Aceitação</b></b></td>
<td class="org-left">Similar aos testes de sistema, com o foco principal em verificar se os requisitos foram atendidos conforme a especificação.</td>
</tr>

<tr>
<td class="org-left"><b><b>Teste Estrutural (Caixa branca)</b></b></td>
<td class="org-left">Técnica em que todos os testes são executados com conhecimento do código-fonte. Capaz de detectar quantidade substancial de erros garantindo a execução de comandos e condições. Inclui critérios baseados na complexidade e fluxo de controle.</td>
</tr>

<tr>
<td class="org-left"><b><b>Critérios baseados na complexidade (Teste Estrutural)</b></b></td>
<td class="org-left">Utilizam informações sobre a complexidade do programa para derivar requisitos de software. Ex: complexidade ciclomática e caminhos linearmente independentes.</td>
</tr>

<tr>
<td class="org-left"><b><b>Complexidade ciclomática</b></b></td>
<td class="org-left">Métrica de software que proporciona uma medida quantitativa da complexidade lógica de um programa. Para n estruturas de seleção/repetição, a complexidade é n+1. Indica o número máximo de caminhos necessários para exercitar todos os comandos. Programas com complexidade &lt;= 10 são simples.</td>
</tr>

<tr>
<td class="org-left"><b><b>Caminhos linearmente independentes</b></b></td>
<td class="org-left">Qualquer caminho do programa que introduza pelo menos um novo conjunto de instruções ou uma nova condição. Determinados a partir do grafo de fluxo de controle (GFC).</td>
</tr>

<tr>
<td class="org-left"><b><b>Grafo de fluxo de controle (GFC)</b></b></td>
<td class="org-left">Representação de um programa colocando comandos em nós e fluxos de controle em arestas. Nodos em sequência podem ser um nó; estruturas de seleção/repetição são nós distintos com arestas de decisão/repetição.</td>
</tr>

<tr>
<td class="org-left"><b><b>Critérios baseados no fluxo de controle (Teste Estrutural)</b></b></td>
<td class="org-left">Utilizam o GFC para determinar quais estruturas são necessárias. Ex: Todos-Nós, Todas-Arestas, Todos-Caminhos.</td>
</tr>

<tr>
<td class="org-left"><b><b>Todos-Nós (Critério de teste estrutural)</b></b></td>
<td class="org-left">Exige que a execução do programa passe ao menos uma vez em cada vértice do GFC, ou seja, que cada comando seja executado pelo menos uma vez.</td>
</tr>

<tr>
<td class="org-left"><b><b>Todas-Arestas (Critério de teste estrutural)</b></b></td>
<td class="org-left">Requer que cada aresta do GFC (cada desvio de fluxo) seja exercitada pelo menos uma vez.</td>
</tr>

<tr>
<td class="org-left"><b><b>Todos-Caminhos (Critério de teste estrutural)</b></b></td>
<td class="org-left">Requer que todos os caminhos possíveis do programa sejam executados.</td>
</tr>

<tr>
<td class="org-left"><b><b>Teste Funcional (Caixa preta)</b></b></td>
<td class="org-left">Executado sobre as entradas e saídas do programa sem conhecimento do código-fonte. Pode detectar todos os defeitos submetendo o programa a todas as entradas possíveis (teste exaustivo). Inclui critérios como particionamento em classes de equivalência, análise do valor-limite e error-guessing.</td>
</tr>

<tr>
<td class="org-left"><b><b>Teste exaustivo</b></b></td>
<td class="org-left">Submeter um programa a todas as possíveis entradas. Geralmente impraticável devido à cardinalidade do domínio de entrada.</td>
</tr>

<tr>
<td class="org-left"><b><b>Particionamento em classes de equivalência (Teste Funcional)</b></b></td>
<td class="org-left">Técnica que divide o domínio de entrada de um programa em conjuntos disjuntos (classes de equivalência), com a suposição de que testar um elemento de um conjunto equivale a testar todos. Requer testar pelo menos um elemento de cada conjunto.</td>
</tr>

<tr>
<td class="org-left"><b><b>Análise do valor-limite (Teste Funcional)</b></b></td>
<td class="org-left">Consiste em considerar valores fronteiriços com outras classes de equivalência para teste, não apenas um valor qualquer dentro de uma classe. Existem diretrizes para definir esses valores (ex: limites de intervalo, valores imediatamente subsequentes, quantidade de valores).</td>
</tr>

<tr>
<td class="org-left"><b><b>Error-guessing (Teste Funcional)</b></b></td>
<td class="org-left">Critério de teste funcional baseado na intuição sobre onde os defeitos provavelmente ocorrem.</td>
</tr>

<tr>
<td class="org-left"><b><b>Teste baseado em defeitos</b></b></td>
<td class="org-left">Técnica em que a fonte para definir os requisitos de teste é uma lista de defeitos conhecidos e suas causas. Inclui a análise de mutantes.</td>
</tr>

<tr>
<td class="org-left"><b><b>Análise de mutantes (Teste baseado em defeitos)</b></b></td>
<td class="org-left">Critério que consiste em simular defeitos conhecidos no código-fonte, criando programas mutantes, e confrontá-los com o código original para revelar defeitos e avaliar a qualidade dos casos de teste.</td>
</tr>

<tr>
<td class="org-left"><b><b>Programa mutante (Análise de mutantes)</b></b></td>
<td class="org-left">Um novo programa produzido pela aplicação de um operador de mutação no programa original.</td>
</tr>

<tr>
<td class="org-left"><b><b>Operadores de mutação (Análise de mutantes)</b></b></td>
<td class="org-left">Regras ou padrões que simulam a forma como os programadores cometem erros. A escolha depende da linguagem de programação e dos tipos de defeitos a serem revelados. Ex: Eliminação de comandos, troca de operador relacional, troca de variáveis.</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="outline-container-org93d4fd4" class="outline-3">
<h3 id="org93d4fd4">Capítulo 6</h3>
<div class="outline-text-3" id="text-org93d4fd4">
</div>
<div id="outline-container-org1177a03" class="outline-4">
<h4 id="org1177a03">Fundamentos e recursos da cultura DevOps</h4>
<div class="outline-text-4" id="text-org1177a03">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Conceito</th>
<th scope="col" class="org-left">Descrição</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><b><b>Cultura de desenvolvimento e operações (DevOps)</b></b></td>
<td class="org-left">Refere-se à junção dos conceitos de desenvolvimento (Dev) e operações (Ops). É uma cultura que faz uso dos conceitos da engenharia de software (processos, testes, projeto, arquitetura, métodos ágeis) de forma colaborativa. Não é uma tecnologia específica, ferramenta ou automatização de processo. Abrange todo o ciclo de vida do desenvolvimento de software.</td>
</tr>

<tr>
<td class="org-left"><b><b>Desenvolvimento (Dev) (DevOps)</b></b></td>
<td class="org-left">Uma das partes que compõem o termo DevOps. Refere-se à equipe de desenvolvimento.</td>
</tr>

<tr>
<td class="org-left"><b><b>Operações (Ops) (DevOps)</b></b></td>
<td class="org-left">Uma das partes que compõem o termo DevOps. Refere-se à equipe de operações.</td>
</tr>

<tr>
<td class="org-left"><b><b>Integração Contínua</b></b></td>
<td class="org-left">Prática na qual o código é compilado para cada mudança e executa testes automatizados minimamente confiáveis. Contrária aos métodos tradicionais que adiam a integração. O time integra o código pelo menos uma vez por dia em um único tronco. A segmentação de implementação é iniciada automaticamente a cada mudança.</td>
</tr>

<tr>
<td class="org-left"><b><b>Princípios da Integração Contínua (Fowler)</b></b></td>
<td class="org-left">Onze princípios que visam tornar a integração contínua mais efetiva, como manter repositório único, automatizar versão, fazer autoteste, commit diário, centralizar commit, corrigir quebra de código imediatamente, manter construção rápida, testar em ambiente próximo à produção, obter executável mais recente, possibilitar visibilidade, automatizar implantação.</td>
</tr>

<tr>
<td class="org-left"><b><b>Arquitetura de referência DevOps</b></b></td>
<td class="org-left">Apresenta a perspectiva dos principais recursos que o DevOps pretende fornecer.</td>
</tr>

<tr>
<td class="org-left"><b><b>Caminhos de adoção do DevOps</b></b></td>
<td class="org-left">Quatro caminhos propostos: Conduzir (estabelecer objetivos de negócio e ajustar com feedback, inclui planejamento contínuo); Desenvolver/testar (duas práticas: desenvolvimento colaborativo e teste contínuo); Entregar (duas práticas: entrega contínua e implantação contínua); Operar (duas práticas: monitoramento contínuo e feedback contínuo).</td>
</tr>

<tr>
<td class="org-left"><b><b>Planejamento contínuo do negócio (DevOps - Conduzir)</b></b></td>
<td class="org-left">Prática incluída no caminho Conduzir.</td>
</tr>

<tr>
<td class="org-left"><b><b>Desenvolvimento colaborativo (DevOps - Desenvolver/testar)</b></b></td>
<td class="org-left">Permite que profissionais trabalhem juntos, fornecendo práticas e plataforma comuns; sua atividade central é a integração contínua.</td>
</tr>

<tr>
<td class="org-left"><b><b>Teste contínuo (DevOps - Desenvolver/testar)</b></b></td>
<td class="org-left">Significa testar mais cedo e continuamente ao longo do ciclo.</td>
</tr>

<tr>
<td class="org-left"><b><b>Entrega contínua (DevOps - Entregar)</b></b></td>
<td class="org-left">Prática incluída no caminho Entregar.</td>
</tr>

<tr>
<td class="org-left"><b><b>Implantação contínua (DevOps - Entregar)</b></b></td>
<td class="org-left">Prática incluída no caminho Entregar.</td>
</tr>

<tr>
<td class="org-left"><b><b>Monitoramento contínuo (DevOps - Operar)</b></b></td>
<td class="org-left">Prática incluída no caminho Operar.</td>
</tr>

<tr>
<td class="org-left"><b><b>Feedback contínuo (DevOps - Operar)</b></b></td>
<td class="org-left">Prática incluída no caminho Operar.</td>
</tr>

<tr>
<td class="org-left"><b><b>Fontes de ineficiências na entrega de software</b></b></td>
<td class="org-left">Categorias de ineficiências que o DevOps busca mitigar: supercarga desnecessária (comunicar várias vezes a mesma informação); retrabalho desnecessário (defeitos descobertos tardiamente); superprodução (funcionalidades desenvolvidas não requeridas).</td>
</tr>

<tr>
<td class="org-left"><b><b>Construir uma cultura DevOps</b></b></td>
<td class="org-left">Requer que líderes trabalhem com equipes para criar ambiente de colaboração e compartilhamento, removendo barreiras à cooperação. Medições típicas que colocam Dev e Ops uns contra os outros devem ser substituídas por responsabilidade compartilhada. Práticas ágeis como Scrum estão no centro do DevOps.</td>
</tr>

<tr>
<td class="org-left"><b><b>Princípios básicos para implementar a cultura DevOps</b></b></td>
<td class="org-left">Incluem: foco no que se deseja melhorar; estabelecer métricas para medir desempenho (somente é possível melhorar o que se pode medir); padronizar tarefas.</td>
</tr>

<tr>
<td class="org-left"><b><b>Planejamento de liberação (DevOps)</b></b></td>
<td class="org-left">Função impulsionada pelas necessidades comerciais de oferecer recursos mais rápido; aproveita práticas ágeis para planejar prazos com mais frequência e focar na qualidade.</td>
</tr>

<tr>
<td class="org-left"><b><b>Mitos sobre DevOps</b></b></td>
<td class="org-left">Crenças comuns e incorretas sobre o DevOps, como a de que é apenas para desenvolvedores e administradores de sistemas (quando na verdade abrange todas as funções da organização).</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="outline-container-org55146f8" class="outline-3">
<h3 id="org55146f8">Observações&#x2026;</h3>
<div class="outline-text-3" id="text-org55146f8">
</div>
<div id="outline-container-orgf703c25" class="outline-4">
<h4 id="orgf703c25">Como organizei o conteúdo desta página</h4>
<div class="outline-text-4" id="text-orgf703c25">
<p>
Esta página contém resumos dos principais conceitos da disciplina sistema gerenciador de banco de dados, extraídos de arquivos no formato PDF com a ferramenta <a href="https://notebooklm.google.com">NotebookLM</a>.
</p>

<p>
De forma simples, enviei os arquivos para o NotebookLM e pedi os resumos com os seguintes comandos:
</p>

<p>
<b>Organize uma tabela com os principais conceitos do texto. Na primeira coluna, o nome do conceito e na segunda, o conceito em si.</b>
</p>

<p>
A partir do segundo pedido, usei o comando:
</p>

<p>
<b>Repita o processo anterior para este texto.</b>
</p>

<p>
No terceiro pedido, recebi a mensage de:
</p>

<p>
<b>O comando fornecido solicita que o processo anterior seja repetido. No entanto, não há processo anterior no histórico de conversas fornecido. [Me] Para obter uma resposta abrangente, forneça o processo anterior que você gostaria que fosse repetido.</b>
</p>

<p>
Desta forma, alternei entre o primeiro e segundo comando até o último arquivo, que veio com a formatação Markdown deformada. Então, pedi uma última revisão com o comando:
</p>

<p>
<b>Refaça a tabela para uma melhor formatação em Markdown.</b>
</p>

<p>
A publicação final continua uma exportação simples, do formato org mode para HTML, usando o Emacs.
</p>
</div>
</div>
</div>
<div id="outline-container-orgb80a374" class="outline-2">
<h2 id="orgb80a374"><a href="./index.html">Voltar para o início&#x2026;</a></h2>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Autor: Jackson de Jesus</p>
<p class="date">Criado em: 14-05-2025, qua 20:31</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
