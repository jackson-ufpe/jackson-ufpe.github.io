<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="pt-br" xml:lang="pt-br">
<head>
<!-- 2024-07-15 seg 10:21 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Banco de dados</title>
<meta name="author" content="Jackson de Jesus" />
<meta name="description" content="Resumo dos conceitos de banco de dados" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/readtheorg.js"></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Banco de dados</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org17182df">Conceitos de Banco de Dados: resumo</a>
<ul>
<li><a href="#orge0e4827">Capítulo 1</a></li>
<li><a href="#org315111f">Capítulo 2</a></li>
<li><a href="#org4e2b8e6">Capítulo 3</a></li>
<li><a href="#orge763831">Capítulo 4</a></li>
<li><a href="#org05c1299">Capítulo 5</a></li>
<li><a href="#org0c6063c">Capítulo 6</a></li>
<li><a href="#org62b73f5">Como organizei o conteúdo desta página</a></li>
</ul>
</li>
<li><a href="#orge246783">Voltar para o início&#x2026;</a></li>
</ul>
</div>
</div>

<div id="outline-container-org17182df" class="outline-2">
<h2 id="org17182df">Conceitos de Banco de Dados: resumo</h2>
<div class="outline-text-2" id="text-org17182df">
</div>
<div id="outline-container-orge0e4827" class="outline-3">
<h3 id="orge0e4827">Capítulo 1</h3>
<div class="outline-text-3" id="text-orge0e4827">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Conceito</th>
<th scope="col" class="org-left">Descrição</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><b><b>Dado</b></b></td>
<td class="org-left">Fatos brutos e isolados que representam uma informação básica.</td>
</tr>

<tr>
<td class="org-left"><b><b>Informação</b></b></td>
<td class="org-left">Conjunto de dados organizados e processados que adquirem significado e se tornam úteis para a tomada de decisões.</td>
</tr>

<tr>
<td class="org-left"><b><b>Banco de Dados (BD)</b></b></td>
<td class="org-left">Local onde os dados de uma aplicação são armazenados de forma estruturada.</td>
</tr>

<tr>
<td class="org-left"><b><b>Sistema Gerenciador de Banco de Dados (SGBD)</b></b></td>
<td class="org-left">Software que permite aos usuários interagir com os dados armazenados no banco de dados, fornecendo ferramentas para acessar, manipular e gerenciar as informações.</td>
</tr>

<tr>
<td class="org-left"><b><b>Modelagem de Dados</b></b></td>
<td class="org-left">Processo de representação visual e conceitual da estrutura de um banco de dados, mostrando as entidades, seus atributos e as relações entre elas.</td>
</tr>

<tr>
<td class="org-left"><b><b>Modelo Conceitual</b></b></td>
<td class="org-left">Representação abstrata e de alto nível de um banco de dados, focando nas entidades, seus atributos e as relações entre elas, independente da implementação física ou do SGBD utilizado.</td>
</tr>

<tr>
<td class="org-left"><b><b>Modelo Lógico</b></b></td>
<td class="org-left">Descreve o banco de dados no nível do SGBD escolhido, definindo as tabelas, colunas, tipos de dados e restrições de integridade, considerando as características específicas do SGBD.</td>
</tr>

<tr>
<td class="org-left"><b><b>Modelo Físico</b></b></td>
<td class="org-left">Detalha como o banco de dados será implementado fisicamente no sistema de armazenamento, definindo a organização dos arquivos, índices, tamanho dos campos e outros aspectos físicos.</td>
</tr>

<tr>
<td class="org-left"><b><b>Entidade</b></b></td>
<td class="org-left">Representação abstrata de um objeto do mundo real sobre o qual queremos armazenar informações em um banco de dados.</td>
</tr>

<tr>
<td class="org-left"><b><b>Campo (Atributo)</b></b></td>
<td class="org-left">Característica específica de uma entidade, armazenando um tipo específico de dado, como nome, data de nascimento, endereço, etc.</td>
</tr>

<tr>
<td class="org-left"><b><b>Relacionamento</b></b></td>
<td class="org-left">Associação entre duas ou mais entidades, representando como elas se conectam e interagem no modelo de dados.</td>
</tr>

<tr>
<td class="org-left"><b><b>Chave Primária (PK)</b></b></td>
<td class="org-left">Campo ou conjunto de campos que identifica unicamente cada instância de uma entidade.</td>
</tr>

<tr>
<td class="org-left"><b><b>Chave Estrangeira (FK)</b></b></td>
<td class="org-left">Campo em uma tabela que se relaciona com a chave primária de outra tabela, estabelecendo um link entre as entidades.</td>
</tr>

<tr>
<td class="org-left"><b><b>Cardinalidade</b></b></td>
<td class="org-left">Define a quantidade de instâncias de uma entidade que podem estar relacionadas a instâncias de outra entidade em um relacionamento.</td>
</tr>

<tr>
<td class="org-left"><b><b>Entidade Associativa</b></b></td>
<td class="org-left">Criada para representar um relacionamento muitos-para-muitos (N:N) entre duas entidades, contendo as chaves estrangeiras de ambas as entidades.</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org315111f" class="outline-3">
<h3 id="org315111f">Capítulo 2</h3>
<div class="outline-text-3" id="text-org315111f">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Conceito</th>
<th scope="col" class="org-left">Descrição</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><b><b>Modelo Relacional</b></b></td>
<td class="org-left">Modelo de dados adequado para um SGBD específico, baseado no princípio de que todos os dados estão armazenados em tabelas.</td>
</tr>

<tr>
<td class="org-left"><b><b>Tupla</b></b></td>
<td class="org-left">Conjunto horizontal de dados presentes nos atributos, similar a um registro ou linha em uma tabela.</td>
</tr>

<tr>
<td class="org-left"><b><b>Atributo</b></b></td>
<td class="org-left">Nome que identifica o dado armazenado em um banco de dados, equivalente a uma coluna em uma tabela.</td>
</tr>

<tr>
<td class="org-left"><b><b>Domínio</b></b></td>
<td class="org-left">Tipo de dado (inteiro, caractere, decimal, data, etc.) que define o tamanho, os valores permitidos e os padrões de validação para um atributo.</td>
</tr>

<tr>
<td class="org-left"><b><b>Relação</b></b></td>
<td class="org-left">Conjunto de tuplas que formam uma tabela, representando um objeto específico dentro do banco de dados.</td>
</tr>

<tr>
<td class="org-left"><b><b>Álgebra Relacional</b></b></td>
<td class="org-left">Linguagem formal de consulta que permite manipular relações (tabelas) através de operadores, como seleção, projeção e junção, para obter um resultado desejado.</td>
</tr>

<tr>
<td class="org-left"><b><b>Operador de Seleção (Where)</b></b></td>
<td class="org-left">Seleciona um subconjunto de tuplas de uma relação com base em uma condição pré-estabelecida, similar à aplicação de um filtro em uma tabela.</td>
</tr>

<tr>
<td class="org-left"><b><b>Operador de Projeção (Select)</b></b></td>
<td class="org-left">Retorna apenas colunas específicas de uma relação, similar a escolher quais colunas exibir em uma tabela.</td>
</tr>

<tr>
<td class="org-left"><b><b>Restrições de Integridade</b></b></td>
<td class="org-left">Regras aplicadas a um banco de dados para garantir a qualidade, consistência e confiabilidade dos dados armazenados.</td>
</tr>

<tr>
<td class="org-left"><b><b>Chave Primária</b></b></td>
<td class="org-left">Atributo ou conjunto de atributos que identifica unicamente cada tupla em uma relação, garantindo que não haja registros duplicados.</td>
</tr>

<tr>
<td class="org-left"><b><b>Chave Estrangeira</b></b></td>
<td class="org-left">Atributo em uma tabela que se relaciona à chave primária de outra tabela, estabelecendo um link entre as entidades e garantindo a integridade referencial.</td>
</tr>

<tr>
<td class="org-left"><b><b>Chave Composta</b></b></td>
<td class="org-left">Chave primária formada por dois ou mais atributos, geralmente utilizada em entidades associativas que representam relacionamentos muitos-para-muitos (N:N).</td>
</tr>

<tr>
<td class="org-left"><b><b>Normalização</b></b></td>
<td class="org-left">Processo de organização das relações (tabelas) em um banco de dados para reduzir a redundância de dados e melhorar a integridade dos dados.</td>
</tr>

<tr>
<td class="org-left"><b><b>Formas Normais (FN)</b></b></td>
<td class="org-left">Conjunto de regras e restrições que orientam o processo de normalização, sendo as três primeiras (1FN, 2FN, 3FN) as mais utilizadas na prática.</td>
</tr>

<tr>
<td class="org-left"><b><b>Modelo Físico</b></b></td>
<td class="org-left">Fase final do projeto de banco de dados, onde o modelo lógico é adaptado para um SGBD específico, definindo a organização física dos dados em disco, os tipos de dados, índices e outros aspectos de armazenamento.</td>
</tr>

<tr>
<td class="org-left"><b><b>Schema</b></b></td>
<td class="org-left">Agrupamento lógico de objetos (tabelas, índices, etc.) em um banco de dados, geralmente relacionado a uma área de negócio específica.</td>
</tr>

<tr>
<td class="org-left"><b><b>Modelagem Dimensional</b></b></td>
<td class="org-left">Técnica de modelagem utilizada principalmente em Data Warehouses e Data Marts para otimizar a análise de grandes volumes de dados.</td>
</tr>

<tr>
<td class="org-left"><b><b>Tabela Dimensão</b></b></td>
<td class="org-left">Tabela que descreve e classifica os fatos (medidas) em uma modelagem dimensional, contendo atributos descritivos, como nome do produto, data da venda, etc.</td>
</tr>

<tr>
<td class="org-left"><b><b>Tabela Fato</b></b></td>
<td class="org-left">Tabela que armazena as medidas (fatos) de negócio em uma modelagem dimensional, geralmente com dados numéricos e aditivos, como quantidade vendida, valor total da venda, etc.</td>
</tr>

<tr>
<td class="org-left"><b><b>SQL (Structured Query Language)</b></b></td>
<td class="org-left">Linguagem padrão utilizada para comunicação com bancos de dados relacionais, permitindo criar, consultar, manipular e controlar o acesso aos dados.</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org4e2b8e6" class="outline-3">
<h3 id="org4e2b8e6">Capítulo 3</h3>
<div class="outline-text-3" id="text-org4e2b8e6">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Conceito</th>
<th scope="col" class="org-left">Descrição</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Tipo de Dado</td>
<td class="org-left">Define o padrão de informação que um objeto pode armazenar, como colunas em tabelas, parâmetros em procedimentos, variáveis e funções.</td>
</tr>

<tr>
<td class="org-left">Tipo Numérico</td>
<td class="org-left">Armazenam valores inteiros, de ponto flutuante (sem limite na precisão e escala) ou de ponto fixo (com limite na precisão e escala). Exemplos: `bit`, `tinyint`, `int`, `float`, `decimal`.</td>
</tr>

<tr>
<td class="org-left">Tipo Cadeia de Caracteres (String)</td>
<td class="org-left">Podem ser valores binários (`binary`, `varbinary`, `blob`) ou não binários (`char`, `varchar`, `text`). O tipo `varchar` é mais econômico pois só ocupa o espaço realmente utilizado.</td>
</tr>

<tr>
<td class="org-left">Tipo Valor Temporal</td>
<td class="org-left">Armazenam dados de data e hora. Exemplos: `date`, `time`, `datetime`, `timestamp`, `year`.</td>
</tr>

<tr>
<td class="org-left">Chave Primária (PK)</td>
<td class="org-left">Identificador único de uma linha em uma tabela. Não pode conter valores nulos.</td>
</tr>

<tr>
<td class="org-left">Chave Estrangeira (FK)</td>
<td class="org-left">Faz referência à chave primária de outra tabela, estabelecendo um relacionamento entre elas.</td>
</tr>

<tr>
<td class="org-left">Chave Única (UK)</td>
<td class="org-left">Garante a exclusividade de uma coluna em uma tabela, similar à chave primária, mas permitindo múltiplas declarações por tabela.</td>
</tr>

<tr>
<td class="org-left">Chave Composta</td>
<td class="org-left">Uma chave primária formada por múltiplas colunas.</td>
</tr>

<tr>
<td class="org-left">Restrição</td>
<td class="org-left">Regra que garante a integridade dos dados em um banco de dados. Pode ser aplicada em nível de coluna ou de tabela.</td>
</tr>

<tr>
<td class="org-left">Not Null</td>
<td class="org-left">Impede que uma coluna aceite valores nulos.</td>
</tr>

<tr>
<td class="org-left">Check</td>
<td class="org-left">Define regras específicas para os valores de uma coluna. No MySQL, essa restrição é ignorada.</td>
</tr>

<tr>
<td class="org-left">Default</td>
<td class="org-left">Define um valor padrão para uma coluna caso nenhum valor seja informado.</td>
</tr>

<tr>
<td class="org-left">Autoincrement</td>
<td class="org-left">Gera automaticamente um número inteiro sequencial e incremental para uma coluna, geralmente utilizado em chaves primárias.</td>
</tr>

<tr>
<td class="org-left">Unsigned</td>
<td class="org-left">Impede que uma coluna do tipo inteiro aceite valores negativos.</td>
</tr>

<tr>
<td class="org-left">Zerofill</td>
<td class="org-left">Preenche automaticamente com zeros os espaços não utilizados em uma coluna numérica.</td>
</tr>

<tr>
<td class="org-left">Comandos SQL</td>
<td class="org-left">Instruções utilizadas para interagir com o banco de dados. O texto aborda comandos como: `create database`, `create table`, `insert`, `select`, `drop`, `alter table`.</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orge763831" class="outline-3">
<h3 id="orge763831">Capítulo 4</h3>
<div class="outline-text-3" id="text-orge763831">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Conceito</th>
<th scope="col" class="org-left">Descrição</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">DML (Data Manipulation Language)</td>
<td class="org-left">Linguagem utilizada para manipular os dados armazenados em um banco de dados, incluindo operações de inclusão, modificação, exclusão e consulta de dados.</td>
</tr>

<tr>
<td class="org-left">INSERT</td>
<td class="org-left">Comando SQL utilizado para inserir novos registros em uma tabela.</td>
</tr>

<tr>
<td class="org-left">Sintaxe Simplificada do INSERT</td>
<td class="org-left">Permite inserir valores em todas as colunas da tabela, seguindo a ordem de declaração das mesmas, sem a necessidade de especificar os nomes das colunas. No entanto, essa sintaxe não pode ser utilizada em tabelas com colunas que possuem a cláusula `auto<sub>increment</sub>`.</td>
</tr>

<tr>
<td class="org-left">INSERT com Colunas Específicas</td>
<td class="org-left">Permite inserir dados em colunas específicas de uma tabela. É necessário especificar os nomes das colunas que receberão os valores.</td>
</tr>

<tr>
<td class="org-left">Chave Estrangeira (FK) em INSERT</td>
<td class="org-left">Ao inserir dados em uma tabela com chave estrangeira, o valor referenciado pela FK deve existir na tabela de origem (tabela "pai").</td>
</tr>

<tr>
<td class="org-left">Subquery em INSERT</td>
<td class="org-left">Permite utilizar um comando `SELECT` aninhado (subquery) para inserir dados na tabela, tornando a operação mais dinâmica e otimizada.</td>
</tr>

<tr>
<td class="org-left">DELETE</td>
<td class="org-left">Comando SQL utilizado para excluir registros de uma tabela.</td>
</tr>

<tr>
<td class="org-left">Cláusula WHERE em DELETE</td>
<td class="org-left">Essencial para filtrar as linhas que serão excluídas, evitando a exclusão acidental de todos os registros da tabela.</td>
</tr>

<tr>
<td class="org-left">Subquery em DELETE</td>
<td class="org-left">Assim como no `INSERT`, o `DELETE` permite o uso de subqueries para tornar o processo de exclusão mais otimizado.</td>
</tr>

<tr>
<td class="org-left">TRUNCATE</td>
<td class="org-left">Comando similar ao `DELETE` que remove todos os registros de uma tabela. É mais rápido que o `DELETE`, mas possui limitações, como a impossibilidade de usar triggers, cascade e replicações.</td>
</tr>

<tr>
<td class="org-left">ON DELETE NO ACTION</td>
<td class="org-left">Declaração padrão para chaves estrangeiras que impede a exclusão de registros na tabela "pai" que estejam relacionados com registros na tabela "filha", garantindo a integridade referencial.</td>
</tr>

<tr>
<td class="org-left">ON DELETE CASCADE</td>
<td class="org-left">Declaração para chaves estrangeiras que permite a exclusão em cascata. Ao excluir um registro na tabela "pai", os registros relacionados na tabela "filha" também são excluídos.</td>
</tr>

<tr>
<td class="org-left">UPDATE</td>
<td class="org-left">Comando SQL utilizado para atualizar registros existentes em uma tabela.</td>
</tr>

<tr>
<td class="org-left">Cláusula SET em UPDATE</td>
<td class="org-left">Utilizada para especificar as colunas que serão atualizadas e seus novos valores.</td>
</tr>

<tr>
<td class="org-left">Cláusula WHERE em UPDATE</td>
<td class="org-left">Recomendada para filtrar os registros que serão atualizados, similar ao `DELETE`.</td>
</tr>

<tr>
<td class="org-left">Subquery em UPDATE</td>
<td class="org-left">Permite utilizar um comando `SELECT` aninhado para atualizar dados na tabela.</td>
</tr>

<tr>
<td class="org-left">ON UPDATE NO ACTION</td>
<td class="org-left">Declaração padrão para chaves estrangeiras que impede a atualização de valores na tabela "pai" que estejam sendo utilizados como chave estrangeira na tabela "filha".</td>
</tr>

<tr>
<td class="org-left">ON UPDATE CASCADE</td>
<td class="org-left">Permite a atualização em cascata. Ao atualizar um valor na tabela "pai", os registros relacionados na tabela "filha" também são atualizados.</td>
</tr>

<tr>
<td class="org-left">Operadores Lógicos</td>
<td class="org-left">Utilizados para combinar condições em uma consulta. Os operadores lógicos são `AND`, `OR` e `NOT`.</td>
</tr>

<tr>
<td class="org-left">Operadores Relacionais</td>
<td class="org-left">Utilizados para comparar valores em uma consulta. Exemplos: `=`, `&lt;&gt;`, `&gt;`, `&lt;`, `&gt;=`, `&lt;=`, `IN`, `NOT IN`, `LIKE`, `BETWEEN`, `IS NULL`, `EXISTS`, `ANY`, `ALL`.</td>
</tr>

<tr>
<td class="org-left">Operadores Aritméticos</td>
<td class="org-left">Utilizados para realizar operações matemáticas em uma consulta. Os operadores aritméticos são `+`, `-`, `*` e `/`.</td>
</tr>

<tr>
<td class="org-left">ORDER BY</td>
<td class="org-left">Cláusula utilizada para ordenar os resultados de uma consulta em ordem crescente (`ASC`) ou decrescente (`DESC`).</td>
</tr>

<tr>
<td class="org-left">JOIN</td>
<td class="org-left">Operação que permite combinar dados de múltiplas tabelas em uma única consulta.</td>
</tr>

<tr>
<td class="org-left">Tipos de JOIN</td>
<td class="org-left">Inner Join, Outer Join (Left Join, Right Join, Full Join), Cross Join e Self Join.</td>
</tr>

<tr>
<td class="org-left">ALIAS</td>
<td class="org-left">Recurso que permite renomear tabelas ou colunas em uma consulta, tornando o código mais legível e intuitivo.</td>
</tr>

<tr>
<td class="org-left">LIMIT</td>
<td class="org-left">Cláusula utilizada para limitar o número de linhas retornadas em uma consulta.</td>
</tr>

<tr>
<td class="org-left">DISTINCT</td>
<td class="org-left">Cláusula utilizada para retornar apenas valores únicos em uma consulta, eliminando duplicatas.</td>
</tr>

<tr>
<td class="org-left">CASE</td>
<td class="org-left">Estrutura utilizada para criar condicionais dentro de uma consulta, permitindo executar diferentes ações com base em diferentes condições.</td>
</tr>

<tr>
<td class="org-left">UNION</td>
<td class="org-left">Operador utilizado para combinar o resultado de múltiplas consultas `SELECT` em um único conjunto de resultados.</td>
</tr>

<tr>
<td class="org-left">UNION ALL</td>
<td class="org-left">Similar ao `UNION`, mas inclui todas as linhas, incluindo duplicatas.</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org05c1299" class="outline-3">
<h3 id="org05c1299">Capítulo 5</h3>
<div class="outline-text-3" id="text-org05c1299">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Conceito</th>
<th scope="col" class="org-left">Descrição</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Subqueries</td>
<td class="org-left">Linhas de comando `select` aninhadas dentro de outros comandos SQL (como `select`, `insert`, `update` ou `delete`), que otimizam consultas e permitem a execução de operações complexas.</td>
</tr>

<tr>
<td class="org-left">Operadores Relacionais em Subqueries</td>
<td class="org-left">Utilizados em conjunto com subqueries para comparar valores retornados pela subquery com a consulta principal. Exemplos: `=`, `&gt;`, `&lt;`, `&gt;=`, `&lt;=`.</td>
</tr>

<tr>
<td class="org-left">Operador `IN`</td>
<td class="org-left">Verifica se um valor presente em uma coluna corresponde a um dos valores retornados por uma subquery ou lista.</td>
</tr>

<tr>
<td class="org-left">Operador `EXISTS`</td>
<td class="org-left">Testa a existência de resultados em uma subquery, retornando verdadeiro (true) se houver pelo menos uma linha resultante, caso contrário, retorna falso (false).</td>
</tr>

<tr>
<td class="org-left">Operador `ANY`</td>
<td class="org-left">Recupera registros da consulta principal que satisfaçam a condição de comparação com qualquer um dos registros retornados pela subquery.</td>
</tr>

<tr>
<td class="org-left">Operador `ALL`</td>
<td class="org-left">Recupera apenas os registros da consulta principal que satisfaçam a condição de comparação com todos os registros retornados pela subquery.</td>
</tr>

<tr>
<td class="org-left">Subquery Correlacionada</td>
<td class="org-left">Subquery que depende da consulta externa para cada linha avaliada, usando um alias da tabela externa na sua própria cláusula `WHERE`.</td>
</tr>

<tr>
<td class="org-left">Funções de Formatação de Dados Textuais</td>
<td class="org-left">Funções do MySQL que manipulam dados do tipo texto, incluindo conversão de maiúsculas e minúsculas, remoção de espaços em branco e extração de partes de strings. Exemplos: `length()`, `upper()`, `lower()`, `trim()`, `substring()`, `replace()`.</td>
</tr>

<tr>
<td class="org-left">Funções de Formatação de Dados Numéricos e Temporais</td>
<td class="org-left">Funções do MySQL que manipulam dados numéricos, de data e hora, como arredondamento, truncamento, extração de partes de datas e cálculos com datas. Exemplos: `round()`, `truncate()`, `curdate()`, `now()`, `date()`, `day()`, `month()`, `year()`, `adddate()`, `datediff()`.</td>
</tr>

<tr>
<td class="org-left">Funções de Agregação/Extração de Dados</td>
<td class="org-left">Funções que sumarizam informações de um conjunto de linhas, como contagem, soma, média, valor mínimo e valor máximo. Exemplos: `count()`, `sum()`, `min()`, `max()`, `avg()`.</td>
</tr>

<tr>
<td class="org-left">Cláusula `GROUP BY`</td>
<td class="org-left">Agrupa linhas com valores idênticos em uma ou mais colunas, permitindo a aplicação de funções de agregação nos grupos formados.</td>
</tr>

<tr>
<td class="org-left">Cláusula `HAVING`</td>
<td class="org-left">Filtra os resultados de uma consulta que usa `GROUP BY`, aplicando condições aos grupos formados.</td>
</tr>

<tr>
<td class="org-left">Segurança de Dados</td>
<td class="org-left">Conjunto de mecanismos que visam prevenir acessos não autorizados aos dados, garantindo a confidencialidade e protegendo informações sensíveis.</td>
</tr>

<tr>
<td class="org-left">Segurança Lógica</td>
<td class="org-left">Controle de acesso a nível de usuário e permissões, definindo quem pode realizar quais operações no banco de dados.</td>
</tr>

<tr>
<td class="org-left">Segurança Física</td>
<td class="org-left">Medidas que protegem o hardware e a infraestrutura do banco de dados contra danos físicos, como falhas de energia ou desastres naturais.</td>
</tr>

<tr>
<td class="org-left">Integridade de Dados</td>
<td class="org-left">Conjunto de regras que garantem a precisão, consistência e validade dos dados armazenados no banco de dados.</td>
</tr>

<tr>
<td class="org-left">Integridade Declarativa</td>
<td class="org-left">Implementada através de restrições definidas na estrutura do banco de dados, como chaves primárias, chaves estrangeiras e tipos de dados.</td>
</tr>

<tr>
<td class="org-left">Integridade Procedural</td>
<td class="org-left">Implementada através de código, como triggers, stored procedures e funções, que validam dados e garantem a integridade em situações mais complexas.</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org0c6063c" class="outline-3">
<h3 id="org0c6063c">Capítulo 6</h3>
<div class="outline-text-3" id="text-org0c6063c">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Conceito</th>
<th scope="col" class="org-left">Descrição</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><b><b>Índices</b></b></td>
<td class="org-left">Estruturas que aceleram a busca e recuperação de linhas em tabelas, otimizando consultas.</td>
</tr>

<tr>
<td class="org-left"><b><b>Tipos de Índices</b></b></td>
<td class="org-left">* <b><b>Clustered:</b></b> organiza a tabela pela coluna indexada (ex: chave primária). Só pode haver um por tabela. &lt;br&gt; * <b><b>Non-clustered:</b></b> ponteiros para os dados, não os reorganiza (ex: chave estrangeira).</td>
</tr>

<tr>
<td class="org-left"><b><b>Visão (View)</b></b></td>
<td class="org-left">Retorna dados de uma consulta salva, simplificando acesso e aumentando segurança.</td>
</tr>

<tr>
<td class="org-left"><b><b>Transações</b></b></td>
<td class="org-left">Conjunto de operações como bloco único, garantindo integridade via "tudo ou nada" - sucesso total ou rollback.</td>
</tr>

<tr>
<td class="org-left"><b><b>Propriedades ACID</b></b></td>
<td class="org-left">Atomicidade, Consistência, Isolamento, Durabilidade - garantem confiabilidade e integridade.</td>
</tr>

<tr>
<td class="org-left"><b><b>Problemas de Concorrência</b></b></td>
<td class="org-left">Leitura suja, não repetida, fantasma, atualização perdida - surgem em acessos simultâneos.</td>
</tr>

<tr>
<td class="org-left"><b><b>Níveis de Isolamento</b></b></td>
<td class="org-left">Read uncommitted, committed, repeatable read, serializable - definem a proteção contra problemas de concorrência.</td>
</tr>

<tr>
<td class="org-left"><b><b>Triggers</b></b></td>
<td class="org-left">Ações disparadas por eventos em tabelas (inserção, atualização, exclusão), antes ou depois.</td>
</tr>

<tr>
<td class="org-left"><b><b>Stored Procedures</b></b></td>
<td class="org-left">Blocos de código SQL reutilizáveis, executados pelo SGBD, para tarefas repetitivas, melhorando segurança e consistência.</td>
</tr>

<tr>
<td class="org-left"><b><b>Functions</b></b></td>
<td class="org-left">Como procedures, mas retornam valor(es), úteis para tarefas específicas, usáveis em outros comandos SQL.</td>
</tr>

<tr>
<td class="org-left"><b><b>Cursores</b></b></td>
<td class="org-left">Permitem percorrer linha a linha o resultado de um SELECT, útil para operações em registros individuais.</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org62b73f5" class="outline-3">
<h3 id="org62b73f5">Como organizei o conteúdo desta página</h3>
<div class="outline-text-3" id="text-org62b73f5">
<p>
Esta página contém resumos dos principais conceitos de banco de dados extraídos de arquivos no formato PDF com a ferramenta <a href="https://notebooklm.google.com">NotebookLM</a>.
</p>

<p>
De forma simples, enviei os arquivos para o NotebookLM e pedi os resumos com os seguintes comandos:
</p>

<p>
<b>Organize uma tabela com os principais conceitos do texto. Na primeira coluna, o nome do conceito e na segunda, o conceito em si.</b>
</p>

<p>
A partir do segundo pedido, usei o comando:
</p>

<p>
<b>Repita o processo anterior para este texto.</b>
</p>

<p>
No terceiro pedido, recebi a mensage de:
</p>

<p>
<b>O comando fornecido solicita que o processo anterior seja repetido. No entanto, não há processo anterior no histórico de conversas fornecido. [Me] Para obter uma resposta abrangente, forneça o processo anterior que você gostaria que fosse repetido.</b>
</p>

<p>
Desta forma, alternei entre o primeiro e segundo comando até o último arquivo, que veio com a formatação Markdown deformada. Então, pedi uma última revisão com o comando:
</p>

<p>
<b>Refaça a tabela para uma melhor formatação em Markdown.</b>
</p>

<p>
A publicação final continua uma exportação simples, do formato org mode para HTML, usando o Emacs.
</p>
</div>
</div>
</div>

<div id="outline-container-orge246783" class="outline-2">
<h2 id="orge246783"><a href="./index.html">Voltar para o início&#x2026;</a></h2>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Jackson de Jesus</p>
<p class="date">Created: 2024-07-15 seg 10:21</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
